Создание `int` с помощью литерала
```python
1 # 1
```

```python
-10 # -10
```

Создание `float` с помощью литерала (чтобы создать float нужно использовать точку)

```python
1.0 # 1.0
```

```python
-10.5 # -10.5
```

Создание `boolean` с помощью литерала

```python
True # True
```

```python
False # False
```

`float` не всегда имеет точное представление, например

```python
0.1 # 0.1
```

Python отобразит этот литерал как 0.1, но на самом деле это не так. Если вывести 25 знаков после точки, то мы увидем более точное представление числа 0.1

```python
format(0.1, ".25f") # 0.1000000000000000055511151
```

Но некоторые числа имеют конечное представление, например 0,125

```python
format(0.125, ".25f") # 0.1250000000000000000000000
```

При сравнении целых чисел никаких сюрпризов нет

```python
1 + 1 + 1 == 3 # True
```

Некоторые float числа тоже сравниваются правильно (с точки зрения 10сс). Потому что число 0.125 имеет конечное представление в 2сс.

```python
0.125 + 0.125 + 0.125 == 0.375 # True
```

```python
0.1 + 0.1 + 0.1 == 0.3 # False
```

Почему 0.1 + 0.1 + 0.1 == 0.3 вернул False? 

```python
format(0.1 + 0.1 + 0.1, ".25f") # 0.3000000000000000444089210
format(0.3, ".25f") # 0.2999999999999999888977698
```

Эти float числа на самом деле не равны,
`0.3000000000000000444089210 != 0.2999999999999999888977698`
вот почему вернулся False

Для того, чтобы сравнивать float числа, нужно использовать некую допустимую точность. Например, сравнить 2 числа с точностью до 0,001

Сделать это можно так
```python
abs((0.1 + 0.1 + 0.1) - 0.3) < 0.001 # True
```

`abs` – функция получения модуля числа
